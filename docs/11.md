## 9.测验和练习入门

> 原文： [http://exploringjs.com/impatient-js/ch_quizzes-exercises.html](http://exploringjs.com/impatient-js/ch_quizzes-exercises.html)

在大多数章节中，都有测验和练习。这些是付费功能，但可以进行全面预览。本章介绍如何开始使用它们。

### 9.1。测验

安装：

*   下载并解压缩`impatient-js-quiz.zip`

运行测验应用程序：

*   在 Web 浏览器中打开`impatient-js-quiz/index.html`
*   你会看到所有测验的 TOC。

### 9.2。演习

#### 9.2.1。安装练习

安装练习：

*   下载并解压缩`impatient-js-code.zip`
*   按照`README.txt`中的说明进行操作

#### 9.2.2。跑步练习

*   练习由本书中的路径引用。
    *   例如：`exercises/syntax/first_module_test.js`
*   在每个文件中：
    *   第一行包含运行练习的命令。
    *   以下几行描述了您必须做的事情。

### 9.3。 JavaScript 中的单元测试

本书中的所有练习都是通过测试框架 [Mocha](https://mochajs.org) 运行的测试。本节简要介绍。

#### 9.3.1。典型的测试

典型的测试代码分为两部分：

*   第 1 部分：要测试的代码。
*   第 2 部分：代码的测试。

举例来说，以下两个文件：

*   `id.js`（待测代码）
*   `id_test.js`（测试）

##### 9.3.1.1。第 1 部分：代码

代码本身驻留在`id.js`中：

```js
export function id(x) {
  return x;
}
```

这里的关键是：必须导出要测试的所有内容。否则，测试代码无法访问它。

##### 9.3.1.2。第 2 部分：测试

![](img/214efb09e8a6ea25668102c7098d3668.svg) **不要担心测试的确切细节**

您无需担心测试的确切细节：它们始终为您实施。因此，您只需要阅读它们，但不要写它们。

代码测试位于`id_test.js`：

```js
import {strict as assert} from 'assert'; // (A)
import {id} from './id.js'; // (B)

test('My test', () => { // (C)
  assert.equal(id('abc'), 'abc'); // (D)
});
```

该测试文件的核心是 D 行 - [断言](ch_assertion-api.html)：`assert.equal()`指定`id('abc')`的预期结果是`'abc'`。

至于其他线路：

*   A 行：我们导入断言库。
*   B 行：我们导入要测试的功能。
*   C 行：我们定义一个测试。这是通过调用函数`test()`来完成的：
    *   第一个参数：测试的名称。
    *   第二个参数：测试代码（通过零参数的箭头函数提供）。

要运行测试，我们在命令行中执行以下命令：

```js
npm t demos/syntax/id_test.js
```

`t`是`test`的缩写。也就是说，这个命令的长版本是：

```js
npm test demos/syntax/id_test.js
```

![](img/326f85074b5e7828bef014ad113651df.svg) **运动：你的第一次运动**

以下练习让您初步了解练习的内容：`exercises/syntax/first_module_test.js`

#### 9.3.2。摩卡中的异步测试

![](img/214efb09e8a6ea25668102c7098d3668.svg) **阅读**

您可以推迟阅读本节，直到您进入异步编程的章节。

为异步代码编写测试需要额外的工作：测试稍后会收到它的结果，并且必须向 mocha 发出信号，表示它还没有完成，但是当它返回时。以下小节将分析三种方法。

##### 9.3.2.1。致电`done()`

如果测试至少有一个参数，则测试变为异步。该参数通常称为`done`并接收一个代码完成后调用的函数：

```js
test('divideCallback', (done) => {
  divideCallback(8, 4, (error, result) => {
    if (error) {
      done(error);
    } else {
      assert.strictEqual(result, 2);
      done();
    }
  });
});
```

##### 9.3.2.2。回报 Promise

如果返回 Promise，测试也会变为异步。一旦 Promise 完成或被拒绝，Mocha 就会认为测试结束。如果 Promise 得到满足则认为测试成功，如果 Promise 被拒绝则认为测试失败。

```js
test('dividePromise', () => {
  return dividePromise(8, 4)
  .then(result => {
    assert.strictEqual(result, 2);
  });
});
```

##### 9.3.2.3。该测试是异步功能

异步函数总是返回 Promises。因此，异步函数是实现异步测试的便捷方式。以下代码与前面的示例等效。

```js
test('dividePromise', async () => {
  const result = await dividePromise(8, 4);
  assert.strictEqual(result, 2);
  // No explicit return necessary!
});
```

您不需要显式返回任何内容：隐式返回的`undefined`用于实现此异步函数返回的 Promise。如果测试代码抛出异常，则异步函数负责拒绝返回的 Promise。